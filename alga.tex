%% For double-blind review submission
\documentclass[acmlarge,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission
%\documentclass[acmlarge,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission
%\documentclass[acmlarge]{acmart}\settopmatter{}

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage{minted}

\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2017}
\acmMonth{1}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\else\makeatother
%% Conference information (used by SIGPLAN proceedings format)
%% Supplied to authors by publisher for camera-ready submission
\acmConference[PL'17]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
\acmYear{2017}
\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\fi


%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
\setcopyright{none}             %% For review submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}   %% For author/year citations

\begin{document}

\title{Algebraic Graphs with Class}
                                        %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}
                                        %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{}
                                        %% \subtitle is optional
%\subtitlenote{with subtitle note}      %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'

%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{First1 Last1}
\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position1}
  \department{Department1}              %% \department is recommended
  \institution{Institution1}            %% \institution is required
  \streetaddress{Street1 Address1}
  \city{City1}
  \state{State1}
  \postcode{Post-Code1}
  \country{Country1}
}
\email{first1.last1@inst1.edu}          %% \email is recommended

%% Paper note
%% The \thanks command may be used to create a "paper note" ---
%% similar to a title note or an author note, but not explicitly
%% associated with a particular element.  It will appear immediately
%% above the permission/copyright statement.
%\thanks{with paper note}               %% \thanks is optional
                                        %% can be repeated if necesary
                                        %% contents suppressed with 'anonymous'


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
The paper presents a minimalistic, elegant and powerful approach to working
with graphs in a functional programming language. The approach is built on
a rigorous mathematical foundation --- an algebra of graphs --- that allows
to apply equational reasoning for proving the correctness of graph transformation
algorithms. One useful feature of the presented approach compared to the
state-of-the-art graph libraries is that it allows to avoid partial functions on
graphs, which are typically required for handling `malformed graphs' that contain an
edge referring to a non-existent vertex. Algebraic graphs make it impossible to
specify such malformed graphs, thereby eliminating the need for partial functions.

The basic definition of algebraic graphs corresponds to unlabelled directed graphs.
We show that by introducing additional axioms to the algebra, it is possible to also
represent undirected, reflexive, transitively closed, and labelled graphs.
We derive basic graph transformation algorithms that are polymorphic and can
therefore be reused by all graph instances, and demonstrate the flexibility of
algebraic graphs by a few examples.
\end{abstract}

%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10002950.10003624.10003633</concept_id>
<concept_desc>Mathematics of computing~Graph theory</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003752.10010124.10010125.10010127</concept_id>
<concept_desc>Theory of computation~Functional constructs</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Mathematics of computing~Graph theory}
\ccsdesc[500]{Theory of computation~Functional constructs}%% End of generated code

\keywords{algebra, graph, polymorphism, functional programming}

%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

\section{Introduction}

Graphs are ubiquitous in computing, yet working with graphs often requires
painfully low-level fiddling with vertices and edges. As a motivating
example, we look at two popular Haskell graph libraries\footnote{In this paper
we exclusively use Haskell, but the presented approach can be adapted to
other functional programming languages.}. The first one is available from the
\textbf{\textsf{containers}} package and uses adjacency arrays to represent graphs,
as described by King and Launchbury~\citeyear{1995_king_graphs}. The second one
is the \textbf{\textsf{fgl}} library, which is based on \emph{inductive graphs}
by Martin Erwig~\citeyear{2001_erwig_inductive}. Both libraries are
actively maintained, have many users, and provide efficient implementations for
many commonly used graph algorithms. We argue, however, that using these libraries
can be difficult and error-prone, and show how to unlock their algorithmic power
via a simple and safe interface based on \emph{algebraic graphs}.

Fig.~\ref{fig-example} compares the \textbf{\textsf{containers}} and
\textbf{\textsf{fgl}} libraries with algebraic graphs on a sequence of
simple graph transformations: we start with graph $a$ containing the
edge $1 \rightarrow 2$; graph $b$ is obtained by adding the node $3$
and the edge $3 \rightarrow 1$ to $a$; finally, graph $c$ is obtained by removing
the node $2$ from graph $b$. As we show in \S\ref{sec-class}, these graphs can be
described by the following algebraic expressions: $a = 1 \rightarrow 2$,
$b = 1 \rightarrow 2 + 3 \rightarrow 1$ and $c = 3 \rightarrow 1$.

Fig.~\ref{fig-example}(a)

\begin{figure}
\begin{subfigure}[b]{0.28\linewidth}
\begin{minted}[fontsize=\small]{haskell}
import Data.Graph

-- Create graph 1 --> 2
a :: Graph
a = buildG (1,2) [(1,2)]

-- Add edge 3 --> 1
b :: Graph
b = buildG (1,3) $
    edges a ++ [(3,1)]

-- Remove vertex 2
c :: Graph
c = buildG (1,3) $ filter
    (not . adj 2) (edges b)
\end{minted}
\caption{\textbf{\textsf{containers}} library}
\end{subfigure}
\hfill
\vrule
\hfill
\hfill
\begin{subfigure}[b]{0.3\linewidth}
\begin{minted}[fontsize=\small,escapeinside=@@]{haskell}
import Data.Graph.Inductive

-- Create graph 1 --> 2
a :: Graph gr => gr () ()
a = mkUGraph [1,2] [(1,2)]

-- Add edge 3 --> 1
b :: DynGraph gr => gr () ()
b = insEdge (3,1,()) $
    insNode (3,()) a

-- Remove vertex 2
c :: DynGraph gr => gr () ()
c = delNode 2 b
@ @
\end{minted}
\caption{\textbf{\textsf{fgl}} library}
\end{subfigure}
\hfill
\vrule
\hfill
\hfill
\begin{subfigure}[b]{0.35\linewidth}
\begin{minted}[fontsize=\small,escapeinside=@@]{haskell}
import Algebra.Graph

-- Create graph 1 --> 2
a :: (Graph g, Num (Vertex g)) => g
a = edge 1 2

-- Add edge 3 --> 1
b :: (Graph g, Num (Vertex g)) => g
b = overlay a (edge 3 1)


-- Remove vertex 2
c :: (Graph g, Num (Vertex g)
             , Eq  (Vertex g)) => g
c = removeVertex 2 b
\end{minted}
\caption{Algebraic graphs}
\end{subfigure}
\caption{Simple transformations of unlabelled graphs (type signatures are
as inferred by GHC 8.0)\label{fig-example}}
\end{figure}

% Focus not on graph algorithms, but more on convenient graph
% specification/transformation language.

% "Unlike traditional approaches
% based on mutable references or node/edge lists, well-formedness of
% the graph structure is ensured statically and reasoning can be done
% with standard functional programming techniques."


\section{Algebraic graphs}\label{sec-class}

\section{Algebraic structure}\label{sec-algebra}

\section{Graphs a la carte}\label{sec-a-la-carte}

\section{Graphs transformations}\label{sec-transformations}

\section{Applications}\label{sec-applications}

\section{Related work}\label{sec-related}

In this section we review existing approaches to working with graphs developed
by the functional programming community.

\begin{itemize}
    \item Tying the knot:
    \item Borrowing imperative algorithms via the State monad.
    \item Data.Graph by King & Launchbury, 1995. \url{https://galois.com/wp-content/uploads/2014/08/pub_JL_StructuringDFSAlgorithms.pdf}.
    Clever tricks exploiting lazy evaluation (Johnsson 1998) \url{https://pdfs.semanticscholar.org/a6ed/4e55f148e0c48445269990102838f7d7abb5.pdf?_ga=1.176470501.1134931652.1487554701}

    \item Inductive Graphs by Martin Erwig, 2001. \url{https://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf}
    \item Structured Graphs by Oliveira & Cook. \url{https://www.cs.utexas.edu/~wcook/Drafts/2012/graphs.pdf}
    \item An initial-algebra approach to directed acyclic graphs, by J. Gibbons
    \item "Algebras for graphs have been studied in the context of graph rewriting, see Bauderon and Courcelle (1986), for example."
\end{itemize}


%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}

\bibliography{publications}

\appendix
\section{Appendix}

Text of appendix \ldots

\end{document}
