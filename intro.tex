%!TEX root = alga.tex
\section{Introduction}\label{sec-intro}

Graphs are ubiquitous in computing, yet working with graphs often requires
painfully low-level fiddling with sets of vertices and edges. Building
high-level abstractions is difficult, because the commonly used
foundation -- the pair $(V, E)$ of vertex set $V$ and edge set $E$ -- is a source
of partial functions. If $E \nsubseteq V \times V$, the pair is inconsistent and
does not correspond to a graph. This inherent partiality often leaks through
abstractions in state-of-the-art Haskell\footnote{In this paper
we exclusively use Haskell, but the presented approach can be adapted to other
programming languages.} graph libraries.

For example, the \textsf{containers} library represents graphs by
\emph{adjacency arrays}~\cite{1995_king_graphs}. To construct a graph
one specifies the pair $(V,E)$, e.g.
\hs{buildG (1,3) [(1,2),(2,3)]} constructs the graph with $V=\{1,2,3\}$ and
$E=\{(1,2), (2,3)\}$. Note that \hs{buildG} is partial:
\hs{buildG (1,2) [(3,1)]} is well-typed but fails with the
\textsf{`index out of range'} error. Another popular library \textsf{fgl}
uses the \emph{inductive graph representation} by~\citet{2001_erwig_inductive},
but its graph construction API is also based on sets of vertices and edges and
has partial functions, e.g. \hs{insEdge} can fail with
the \textsf{`edge from non-existent vertex'} error. Both \textsf{containers}
and \textsf{fgl} are treasure troves of graph algorithms, but it is easy to make an
error when using them. One can wrap these libraries in a safe interface, but the
question is: What is the right interface for constructing graphs? Is there a better
foundation than the pair $(V, E)$?

We present \emph{algebraic graphs} --- a new interface
for graph construction and transformation. We abstract away from graph representation
details and characterise graphs and two operations on them by a set of axioms,
much like numbers with addition and multiplication are algebraically characterised
by \emph{rings}~\cite{1999_maclane_algebra}. The presented approach is inspired by the
\emph{algebra of parameterised graphs}, a mathematical formalism used in digital
circuit design~\cite{2014_algebra_mokhov}, which we distil and adapt to the context
of functional programming.

The two binary operations on algebraic graphs, called \emph{overlay} and \emph{connect},
have two important properties: i) they are closed on the set of graphs, i.e. are total
functions, and ii) they can be used to construct any graph starting from the \emph{empty} and
single-\emph{vertex} graphs. This leads us to the safe and minimalistic core of four graph
construction primitives, as captured by the following data type:

\begin{minted}{haskell}
data Graph a = Empty
             | Vertex a
             | Overlay (Graph a) (Graph a)
             | Connect (Graph a) (Graph a)
\end{minted}

\noindent
To make the core more reusable we also define the following type class\footnote{The
name collision is not a problem in practice, because the data type and type class
are not used together and can be defined in separate modules.}, whose
instances must obey the axioms of the algebra:

\begin{minted}{haskell}
class Graph g where
    type Vertex g
    empty   :: g
    vertex  :: Vertex g -> g
    overlay :: g -> g -> g
    connect :: g -> g -> g
\end{minted}

\noindent
The main idea of the paper is that this simple core is as a solid foundation for
working with graphs. The type class has classic inhabitants, such as the pair $(V,E)$,
data types from \textsf{containers} and \textsf{fgl}, as well as new, unknown forms
of life. Our contributions are:
\begin{itemize}
  \item Compared to existing libraries, algebraic graphs have a smaller
  core (just four graph construction primitives), are more compositional
  (hence greater code reuse), and have no partial functions (hence fewer
  opportunities for usage errors). We present the core and justify these claims
  in \S\ref{sec-core}.

  \item The core has a simple mathematical structure fully characterised
  by a set of axioms~(\S\ref{sec-algebra}). This makes the
  proposed interface easier for testing and formal verification. We show that
  the core is \emph{complete}, i.e. any graph can be constructed, and \emph{sound},
  i.e. malformed graphs cannot be constructed.

  \item Under the basic set of axioms, algebraic graphs correspond to directed
  graphs with no edge labels. As we show in~\S\ref{sec-a-la-carte}, by extending
  the algebra
  with additional axioms, it is possible to also represent undirected, reflexive
  and transitive graphs, their combinations, as well as hypergraphs.
%   Importantly, the core
%   graph construction primitives remain unchanged, which allows to define highly
%   reusable polymorphic functions on graphs.

  \item We develop a library\footnote{The library is on Hackage:
  \url{http://hackage.haskell.org/package/algebraic-graphs}.} for polymorphic graph
  construction and transformation on top of the algebraic core and
  demonstrate its flexibility in \S\ref{sec-transformations}.
  % Although the development of efficient algorithms for algebraic
  % graphs is outside the scope of this paper, we show that the library can cope
  % with graphs comprising billions of edges in the matter of
  % seconds, which is sufficiently fast for many applications.
\end{itemize}

Graphs and functional programming have a long history. We review related
work in \S\ref{sec-related}. Limitations of this work and future
research directions are discussed in \S\ref{sec-discussion}.
